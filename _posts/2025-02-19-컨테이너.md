---
title: "[C++] 벡터"
excerpt: "C++ STL 벡터"

categories: # 카테고리 설정
  - C++
tags: # 포스트 태그
  - [tag1, tag2]

permalink: /C++/벡터/ # 포스트 URL

toc: true # 우측에 본문 목차 네비게이션 생성
toc_sticky: true # 본문 목차 네비게이션 고정 여부

date: 2025-02-19 # 작성 날짜
last_modified_at: 2025-02-19 # 최종 수정 날짜
---

## STL 컨테이너

### 컨테이너 특성
- STL에서 제공하는 데이터를 저장하고 관리하는 저장소이다.
- 각 컨테이너 메서드의 시간복잡도를 알아 두는 것이 중요하다.
- 비슷한 동작을 하나 시간복잡도가 다른 경우 알아 둘 필요가 있다.
- 각 알고리즘에 적합한 자료구조를 적용하자.

### vector
- 배열처럼 사용 가능한 컨테이너이다. 임의 접근이 가능하다.
- 원소의 수에 따라 내부 배열 크기가 자동으로 증가.
- 맨 앞 혹은 중간에 원소를 삽입하는 경우 비효율적이다. `O(N)`
- 맨 뒤에 원소를 삽입하는 경우 효율적이다. `O(1)`

### vector 예제 코드
```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    // 벡터 초기화 방법 1: 기본 생성자
    vector<int> vec1;  // 빈 벡터 선언: vec1 = {}

    // 벡터 초기화 방법 2: 크기 지정, 모든 원소 0으로 초기화
    vector<int> vec2(5);  // vec2 = {0, 0, 0, 0, 0}

    // 벡터 초기화 방법 3: 크기와 초기값 지정
    vector<int> vec3(5, 1);  // vec3 = {1, 1, 1, 1, 1}

    // 벡터 초기화 방법 4: 초기화 리스트 사용
    vector<int> vec4 = {1, 2, 3, 4, 5};  // vec4 = {1, 2, 3, 4, 5}

    // 벡터 초기화 방법 5: 다른 벡터로부터 초기화
    vector<int> vec5(vec4);  // vec5 = {1, 2, 3, 4, 5}

    // 벡터 초기화 방법 6: 다른 벡터의 부분 범위로부터 초기화
    vector<int> vec6(vec4.begin() + 1, vec4.end() - 1);  // vec6 = {2, 3, 4}

    // 벡터 메서드 예시
    vector<int> vec;

    // push_back: 벡터의 끝에 원소를 추가합니다.
    // vec.push_back(값)
    // 벡터의 맨 끝에 '값'을 추가합니다.
    // 시간복잡도: 평균 O(1)
    vec.push_back(10);  // vec = {10}
    vec.push_back(20);  // vec = {10, 20}
    vec.push_back(30);  // vec = {10, 20, 30}

    // pop_back: 벡터의 마지막 원소를 제거합니다.
    // vec.pop_back()
    // 벡터의 맨 끝에 있는 원소를 제거합니다.
    // 시간복잡도: O(1)
    vec.pop_back();  // vec = {10, 20}

    // insert: 지정한 위치에 원소를 삽입합니다.
    // vec.insert(위치, 값)
    // '위치'에 '값'을 삽입합니다. '위치'는 반복자로 지정합니다.
    // vec.begin()은 첫 번째 원소를 가리킵니다.
    // vec.begin() + 1은 두 번째 원소를 가리킵니다.
    // 시간복잡도: O(n)
    vec.insert(vec.begin() + 1, 15);  // vec = {10, 15, 20}

    // erase: 지정한 위치의 원소를 제거합니다.
    // vec.erase(위치)
    // '위치'의 원소를 제거합니다. '위치'는 반복자로 지정합니다.
    // vec.begin()은 첫 번째 원소를 가리킵니다.
    // 시간복잡도: O(n)
    vec.erase(vec.begin());  // vec = {15, 20}

    // size: 벡터의 크기를 반환합니다.
    // vec.size()
    // 현재 벡터에 저장된 원소의 개수를 반환합니다.
    // 시간복잡도: O(1)
    cout << "Size of vector: " << vec.size() << endl;  // 출력: Size of vector: 2
}
```

### vector를 사용해야 하는 경우

1. 동적 배열이 필요한 경우
    -  프로그램 실행 중에 배열의 크기를 변경해야 하는 경우가 이에 해당한다.
```c++
 vector<int> dynamicArray;
    for (int i = 0; i < 10; ++i) {
        dynamicArray.push_back(i * 2);  // {0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
    }
    cout << "Dynamic array: ";
    for (int v : dynamicArray) {
        cout << v << " ";
    }
    cout << endl; vector<int> dynamicArray;
    for (int i = 0; i < 10; ++i) {
        dynamicArray.push_back(i * 2);  // {0, 2, 4, 6, 8, 10, 12, 14, 16, 18}
    }
    cout << "Dynamic array: ";
    for (int v : dynamicArray) {
        cout << v << " ";
    }
    cout << endl;
```
2. 임의 접근이 필요한 경우
    - 특정 인덱스에 접근해야 하는 경우가 이에 해당한다.
3. 데이터의 크기가 자주 바뀌는 경우
    - 데이터의 추가와 삭제가 빈번하게 발생하는 경우가 이에 해당한다.
```c++
 vector<int> flexibleArray;
    flexibleArray.push_back(1); // {1}
    flexibleArray.push_back(2); // {1, 2}
    flexibleArray.pop_back();   // {1}
```

이와 반대로 vector를 사용하면 안좋은 경우는 다음과 같다.
1. 값을 자주 찾아야 할 때
2. 맨 앞에 원소를 추가해야 할 때
